using Npc.Api.Services;
using Npc.Api.Data;
using Microsoft.EntityFrameworkCore;
using Npc.Api.Entities;
using Neo4j.Driver;

namespace Npc.Api.Infrastructure.BackgroundJobs
{
    public class BackgroundJobs
    {
        private readonly ILogger<BackgroundJobs> _logger;
        private readonly IServiceProvider _serviceProvider;

        public BackgroundJobs(ILogger<BackgroundJobs> logger, IServiceProvider serviceProvider)
        {
            _logger = logger;
            _serviceProvider = serviceProvider;
        }

        [Hangfire.DisableConcurrentExecution(timeoutInSeconds: 300)]
        public async Task GenerateCharacterImageAsync(Guid characterId, string prompt, CancellationToken ct)
        {
            using var scope = _serviceProvider.CreateScope();
            var imageService = scope.ServiceProvider.GetRequiredService<IImageGenService>();
            var dbContext = scope.ServiceProvider.GetRequiredService<CharacterDbContext>();

            try
            {
                _logger.LogInformation("Starting image generation for character {CharacterId}", characterId);

                var character = await dbContext.Characters.FindAsync(characterId, ct);
                if (character == null)
                {
                    _logger.LogWarning("Character {CharacterId} not found for image generation", characterId);
                    return;
                }

                // Simulate image generation for now
                var imageResult = new { Success = true, ImageUrl = $"https://example.com/generated/{characterId}.png", Error = (string?)null };

                if (imageResult.Success)
                {
                    character.ImageUrl = imageResult.ImageUrl;
                    await dbContext.SaveChangesAsync(ct);

                    _logger.LogInformation("Successfully generated image for character {CharacterId}: {ImageUrl}",
                        characterId, imageResult.ImageUrl);
                }
                else
                {
                    _logger.LogError("Failed to generate image for character {CharacterId}: {Error}",
                        characterId, imageResult.Error);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error generating image for character {CharacterId}", characterId);
                throw;
            }
        }

        [Hangfire.DisableConcurrentExecution(timeoutInSeconds: 600)]
        public async Task BulkGenerateCharactersAsync(Guid worldId, int count, CancellationToken ct)
        {
            using var scope = _serviceProvider.CreateScope();
            var agentService = scope.ServiceProvider.GetRequiredService<IAgentConversationService>();
            var dbContext = scope.ServiceProvider.GetRequiredService<CharacterDbContext>();

            try
            {
                _logger.LogInformation("Starting bulk character generation for world {WorldId}, count: {Count}",
                    worldId, count);

                var world = await dbContext.Worlds.FindAsync(worldId, ct);
                if (world == null)
                {
                    _logger.LogWarning("World {WorldId} not found for bulk character generation", worldId);
                    return;
                }

                var generatedCount = 0;
                for (int i = 0; i < count && !ct.IsCancellationRequested; i++)
                {
                    try
                    {
                        // Create character directly for now
                        var character = new Character
                        {
                            Id = Guid.NewGuid(),
                            Name = $"Generated Character {i + 1}",
                            Age = Random.Shared.Next(18, 80),
                            Description = "A character generated by background job",
                            WorldId = worldId,
                            CreatedAt = DateTime.UtcNow,
                            UpdatedAt = DateTime.UtcNow
                        };

                        dbContext.Characters.Add(character);
                        generatedCount++;

                        // Save in batches of 10
                        if ((i + 1) % 10 == 0)
                        {
                            await dbContext.SaveChangesAsync(ct);
                            _logger.LogDebug("Saved batch of 10 characters for world {WorldId}", worldId);
                        }
                    }
                    catch (Exception ex)
                    {
                        _logger.LogWarning(ex, "Failed to generate character {Index} for world {WorldId}", i + 1, worldId);
                    }
                }

                // Save remaining characters
                await dbContext.SaveChangesAsync(ct);

                _logger.LogInformation("Completed bulk character generation for world {WorldId}. Generated: {GeneratedCount}/{RequestedCount}",
                    worldId, generatedCount, count);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in bulk character generation for world {WorldId}", worldId);
                throw;
            }
        }

        [Hangfire.DisableConcurrentExecution(timeoutInSeconds: 300)]
        public async Task GenerateWorldLoreAsync(Guid worldId, string theme, CancellationToken ct)
        {
            using var scope = _serviceProvider.CreateScope();
            var agentService = scope.ServiceProvider.GetRequiredService<IAgentConversationService>();
            var dbContext = scope.ServiceProvider.GetRequiredService<CharacterDbContext>();

            try
            {
                _logger.LogInformation("Starting lore generation for world {WorldId} with theme '{Theme}'",
                    worldId, theme);

                var world = await dbContext.Worlds.Include(w => w.LoreEntries).FirstOrDefaultAsync(w => w.Id == worldId, ct);
                if (world == null)
                {
                    _logger.LogWarning("World {WorldId} not found for lore generation", worldId);
                    return;
                }

                // Generate 5 lore entries with different aspects
                var aspects = new[] { "History", "Culture", "Geography", "Politics", "Religion" };
                var generatedCount = 0;

                foreach (var aspect in aspects)
                {
                    try
                    {
                        // Create lore directly for now
                        var lore = new Lore
                        {
                            Id = Guid.NewGuid(),
                            Title = $"{aspect} of {world.Name}",
                            Text = $"This is generated {aspect.ToLower()} lore for {world.Name} with the theme of {theme}. " +
                                   "This content would be generated by the AI agent service.",
                            WorldId = worldId,
                            CreatedAt = DateTime.UtcNow,
                            UpdatedAt = DateTime.UtcNow
                        };

                        dbContext.LoreEntries.Add(lore);
                        generatedCount++;

                        _logger.LogDebug("Generated {Aspect} lore for world {WorldId}", aspect, worldId);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogWarning(ex, "Failed to generate {Aspect} lore for world {WorldId}", aspect, worldId);
                    }
                }

                await dbContext.SaveChangesAsync(ct);

                _logger.LogInformation("Completed lore generation for world {WorldId}. Generated: {GeneratedCount}/{TotalAspects}",
                    worldId, generatedCount, aspects.Length);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error generating lore for world {WorldId}", worldId);
                throw;
            }
        }

        [Hangfire.DisableConcurrentExecution(timeoutInSeconds: 600)]
        public async Task CleanupOldConversationsAsync(CancellationToken ct)
        {
            using var scope = _serviceProvider.CreateScope();
            var neo4jDriver = scope.ServiceProvider.GetRequiredService<IDriver>();

            try
            {
                _logger.LogInformation("Starting cleanup of old conversations");

                // Delete conversations older than 30 days with no recent activity
                var cutoffDate = DateTime.UtcNow.AddDays(-30);

                await using var session = neo4jDriver.AsyncSession();
                var result = await session.ExecuteWriteAsync(async tx =>
                {
                    var query = @"
                        MATCH (c:Conversation)
                        WHERE c.lastActivity < $cutoffDate
                        OPTIONAL MATCH (c)-[r]-()
                        DELETE r, c
                        RETURN COUNT(c) as deletedCount";

                    var cursor = await tx.RunAsync(query, new { cutoffDate = cutoffDate.ToString("o") });
                    var record = await cursor.SingleAsync();
                    return record["deletedCount"].As<long>();
                });

                _logger.LogInformation("Cleaned up {DeletedCount} old conversations", result);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error cleaning up old conversations");
                throw;
            }
        }

        public async Task UpdateWorldStatisticsAsync(Guid worldId, CancellationToken ct)
        {
            using var scope = _serviceProvider.CreateScope();
            var dbContext = scope.ServiceProvider.GetRequiredService<CharacterDbContext>();

            try
            {
                _logger.LogInformation("Updating statistics for world {WorldId}", worldId);

                var world = await dbContext.Worlds
                    .Include(w => w.Characters)
                    .Include(w => w.LoreEntries)
                    .FirstOrDefaultAsync(w => w.Id == worldId, ct);

                if (world == null)
                {
                    _logger.LogWarning("World {WorldId} not found for statistics update", worldId);
                    return;
                }

                // Update world statistics (this would be stored in a separate statistics table)
                var characterCount = world.Characters.Count;
                var loreCount = world.LoreEntries.Count;
                var avgCharacterAge = world.Characters.Any() ? world.Characters.Average(c => c.Age) : 0;

                _logger.LogInformation("World {WorldId} statistics - Characters: {CharacterCount}, Lore: {LoreCount}, Avg Age: {AvgAge:F1}",
                    worldId, characterCount, loreCount, avgCharacterAge);

                // Here you could save these statistics to a dedicated table
                // or update cached values in Redis
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error updating statistics for world {WorldId}", worldId);
                throw;
            }
        }
    }
}